package xsw.Nov_Dec;

/*
330. 按要求补齐数组
给定一个已排序的正整数数组 nums，和一个正整数 n 。从 [1, n] 区间内选取任意个数字补充到 nums 中，使得 [1, n] 区间内的任何数字都可以用 nums 中某几个数字的和来表示。请输出满足上述要求的最少需要补充的数字个数。

示例 1:

输入: nums = [1,3], n = 6
输出: 1
解释:
根据 nums 里现有的组合 [1], [3], [1,3]，可以得出 1, 3, 4。
现在如果我们将 2 添加到 nums 中， 组合变为: [1], [2], [3], [1,3], [2,3], [1,2,3]。
其和可以表示数字 1, 2, 3, 4, 5, 6，能够覆盖 [1, 6] 区间里所有的数。
所以我们最少需要添加一个数字。
示例 2:

输入: nums = [1,5,10], n = 20
输出: 2
解释: 我们需要添加 [2, 4]。
示例 3:

输入: nums = [1,2,2], n = 5
输出: 0
*/

import java.util.*;

public class LeedCode330 {

    /*可以这么理解，以[1,5,10]的例子为例:
    我们从1开始遍历,并且维护一个指向nums的下标.一开始是1，而我们看到当前nums数组的第一个元素就是1,所以不需要其他操作.
    直接跳到2，并且让pos指向nums的第二个元素；

    现在,我们的目标数是2,但是当前pos指向的数却是5,显然我们只能自己填充一个2,所以让res+1;
    既然我们已经填过2了,而在2之前可以被覆盖的最长区间长度是1,所以当前可以遍历到的最大区间长度变成了3(即2 + 1);

    然后,我们可以忽略3,直接跳到4(因为上一步已经知道3在最大覆盖范围内了)。
    我们发现4同样比当前pos所指向的nums元素小,所以我们得填入4，即让res+1;
    既然已经填入4了,而我们知道在4之前可以覆盖的连续区间是(1-3),所以当前可以覆盖的最大区间被扩展到了7(即4 + 3)。

    接下来我们可以直接跳过5、6、7来到8,而当前pos所指向的元素是5,所以当前可覆盖的区间大小又可以加上5了(7+5 = 12),并让pos指向下一个元素

    最后我们跳过了7-12，从13开始遍历，这时候pos所指的元素是10,所以覆盖范围变成了12 + 10 = 22 >20，说明可以完全覆盖指定区间了！

    到这里大概能够看出端倪 ：
    我们不断维持一个从1开始的可以被完全覆盖的区间,举个例子,当前可以完全覆盖区间是[1,k]，
    而当前pos所指向的nums中的元素为B,说明在B之前(因为是升序，所以都比B小)的所有元素之和可以映射到1-----k，
    而当我们把B也加入进去后，显然，可映射范围一定向右扩展了B个，也就是变成了1---k+B，这就是解题的思路*/
    public static int minPatches(int[] nums, int n) {
        long curr_range = 0;
        int m = nums.length;
        int res = 0;
        int pos = 0;
        for (long i = 1; i <= n; ) {//i是啥？   i是目前范围之外的第一个数，目前范围为 1 ~ i-1，所以如果nums中有i，那就可以表示到1 ~ i；
            if (pos >= m || i < nums[pos]) {//nums[pos]无法被表示，就把放进去   pos >= m表示数组遍历完了，但是可表示范围还不够
                res++;//增加新的数 i
                curr_range += i;//扩大可表示的范围
            } else {
                curr_range += nums[pos];//nums[pos]在可表示的范围内了，加上他，就直接把范围整体加nums[pos]
                pos++;
            }
            i = curr_range + 1;//i 要跳到范围之外的第一个数，因为里边的数都能表示了
        }

        return res;
    }

    public static void main(String[] args) {

        int[] nums = {2, 5, 10};
        int n = 40;
        System.out.println(minPatches1(nums, n));
    }

    //每次找到未被数组 nums 覆盖的最小的整数 x，在数组中补充 x
    //然后寻找下一个未被覆盖的最小的整数，重复上述步骤直到区间 [1,n] 中的所有数字都被覆盖。
    public static int minPatches1(int[] nums, int n) {
        int patches = 0;
        long x = 1;
        int length = nums.length, index = 0;
        while (x <= n) {
            if (index < length && nums[index] <= x) {//在可表示的范围之内
                x += nums[index];
                index++;
            } else {
                x *= 2;
                patches++;
            }
        }
        return patches;
    }
}
